<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>凌子亦 · 📙 | 设计模式</title>
    <meta name="description" content="写写笔记什么的">
    
    
    <link rel="preload" href="/assets/css/0.styles.c4669b9b.css" as="style"><link rel="preload" href="/assets/js/app.3681f687.js" as="script"><link rel="preload" href="/assets/js/19.55416f59.js" as="script"><link rel="prefetch" href="/assets/js/14.01a12aed.js"><link rel="prefetch" href="/assets/js/1.79e91ea3.js"><link rel="prefetch" href="/assets/js/2.7e8556b8.js"><link rel="prefetch" href="/assets/js/3.70d4f9b7.js"><link rel="prefetch" href="/assets/js/4.aa815117.js"><link rel="prefetch" href="/assets/js/5.57119d85.js"><link rel="prefetch" href="/assets/js/6.0a80ff83.js"><link rel="prefetch" href="/assets/js/7.e6c6f51a.js"><link rel="prefetch" href="/assets/js/8.64d123c3.js"><link rel="prefetch" href="/assets/js/9.5fc801b0.js"><link rel="prefetch" href="/assets/js/10.a985a241.js"><link rel="prefetch" href="/assets/js/11.00572892.js"><link rel="prefetch" href="/assets/js/12.8ed540dd.js"><link rel="prefetch" href="/assets/js/13.83e6fb9b.js"><link rel="prefetch" href="/assets/js/15.ffcd0199.js"><link rel="prefetch" href="/assets/js/16.8ba4a225.js"><link rel="prefetch" href="/assets/js/17.ebd63263.js"><link rel="prefetch" href="/assets/js/18.97452dce.js"><link rel="prefetch" href="/assets/js/20.69494a9a.js"><link rel="prefetch" href="/assets/js/21.84cbdbe9.js"><link rel="prefetch" href="/assets/js/22.c6401b09.js"><link rel="prefetch" href="/assets/js/23.c8a50afe.js"><link rel="prefetch" href="/assets/js/24.15eae7cb.js"><link rel="prefetch" href="/assets/js/25.3ef7ac3e.js"><link rel="prefetch" href="/assets/js/26.0ddc27ca.js"><link rel="prefetch" href="/assets/js/27.d8311d7d.js"><link rel="prefetch" href="/assets/js/28.7c8da951.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c4669b9b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      凌子亦 · 📙
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Articles</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/jottings/" class="nav-link router-link-active">随笔</a></li><li class="dropdown-item"><!----><a href="/blogs/" class="nav-link">博客</a></li></ul></div></div><a href="https://github.com/lainazy" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Articles</span><span class="arrow right"></span></a><ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----><a href="/jottings/" class="nav-link router-link-active">随笔</a></li><li class="dropdown-item"><!----><a href="/blogs/" class="nav-link">博客</a></li></ul></div></div><a href="https://github.com/lainazy" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>自主学习</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/learn-by-self.html" class="sidebar-link">杂记</a></li><li><a href="/jottings/design-pattern.html" class="active sidebar-link">设计模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jottings/design-pattern.html#创建型模式-对象怎么生成" class="sidebar-link">创建型模式 - 对象怎么生成</a></li><li class="sidebar-sub-header"><a href="/jottings/design-pattern.html#结构型模式-对象与对象的关系" class="sidebar-link">结构型模式 - 对象与对象的关系</a></li><li class="sidebar-sub-header"><a href="/jottings/design-pattern.html#行为型模式-对象与对象在干嘛" class="sidebar-link">行为型模式 - 对象与对象在干嘛</a></li><li class="sidebar-sub-header"><a href="/jottings/design-pattern.html#j2ee-模式-对象合起来要干嘛" class="sidebar-link">J2EE 模式 - 对象合起来要干嘛</a></li></ul></li><li><a href="/jottings/web-security.html" class="sidebar-link">web安全及处理</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>浏览器</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/browser-study.html" class="sidebar-link">浏览器学习记录</a></li><li><a href="/jottings/network.html" class="sidebar-link">网络数据传输原理</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Http</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/http-status-code.html" class="sidebar-link">http 常见状态码</a></li><li><a href="/jottings/http-study.html" class="sidebar-link">Http 协议相关记录</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Css</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/css-often-used.html" class="sidebar-link">CSS 常用样式记录</a></li><li><a href="/jottings/css-study.html" class="sidebar-link">CSS 学习记录</a></li><li><a href="/jottings/scss.html" class="sidebar-link">Scss 使用指南</a></li><li><a href="/jottings/stylus.html" class="sidebar-link">Stylus 记录</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Javascript</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/js-study.html" class="sidebar-link">Javascript 学习记录</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>DOM</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/dom-study.html" class="sidebar-link">DOM 笔记</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Vue</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/vuepress-use.html" class="sidebar-link">VuePress 使用指南</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>React</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/react-hooks.html" class="sidebar-link">React Hooks</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Webpack</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/webpack.html" class="sidebar-link">Webpack相关记录</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Git</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/git-cmd.html" class="sidebar-link">Git 命令</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Linux</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/linux-cmd.html" class="sidebar-link">Linux 命令学习记录</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Docker</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/docker-often-used.html" class="sidebar-link">Docker 常用命令记录</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>项目规范</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/husky.html" class="sidebar-link">husky &amp; lint-staged 使用记录</a></li><li><a href="/jottings/commitlint.html" class="sidebar-link">commitizen &amp; commitlint 使用记录</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>持续集成</span><!----></p><ul class="sidebar-group-items"><li><a href="/jottings/travis-use.html" class="sidebar-link">Travis CI 使用摘要</a></li><li><a href="/jottings/gitlab-ci-use.html" class="sidebar-link">Gitlab CI 使用摘要</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="设计模式"><a href="#设计模式" aria-hidden="true" class="header-anchor">#</a> 设计模式</h1><blockquote><p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener noreferrer">设计模式 - 菜鸟教程</a></p></blockquote><h2 id="创建型模式-对象怎么生成"><a href="#创建型模式-对象怎么生成" aria-hidden="true" class="header-anchor">#</a> 创建型模式 - 对象怎么生成</h2><h3 id="工厂模式"><a href="#工厂模式" aria-hidden="true" class="header-anchor">#</a> 工厂模式 **</h3><p>添加一个工厂类，内部调用多个其他简单类，生成多个简单对象，并组合这些简单对象来生成一个复杂对象。</p><p>比如我们需要造一辆车，车由很多个零件组成。</p><ul><li>正常做法：new很多个零件对象，然后组合成一个汽车对象。</li><li>工厂模式：创建一个汽车工厂类，在汽车工厂类内部实现new各个零件对象的操作并组合，最后返回创建的汽车对象，这样我们直接new这个汽车工厂类就可以方便的创建出汽车对象了。</li></ul><p><em>注意：复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。</em></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" aria-hidden="true" class="header-anchor">#</a> 抽象工厂模式</h3><p>抽象工厂模式是工厂模式的强化版，就是再添加一个抽象工厂类，内部要求使用多个分类的子工厂类，添加具体工厂类来实现这个抽象工厂类，最后生成一个更复杂的对象。</p><p>比如套装可以分为商务装和休闲装，每一种又可以分为上衣，裤子，鞋子等等。
我们声明上衣工厂类，裤子工厂类，鞋子工厂类，然后声明一个套装抽象工厂类，要求创建套装时必须使用上衣工厂类，裤子工厂类，鞋子工厂类，然后我们声明商务装工厂类和休闲装工厂类来实现套装抽象工厂类，这样new商务装工厂类，就会自动使用了上衣工厂类，裤子工厂类，鞋子工厂类来创建一个商务套装对象。</p><h3 id="单例模式"><a href="#单例模式" aria-hidden="true" class="header-anchor">#</a> 单例模式 **</h3><p>通常做法就是将类第一次生成的实例对象保留，以后每次再实例化时，直接赋值为之前保留的实例。</p><h3 id="建造者模式"><a href="#建造者模式" aria-hidden="true" class="header-anchor">#</a> 建造者模式</h3><p>将一个复杂对象的创建拆分成多个简单对象的组合。
比如套餐(复杂对象)包含米饭(简单对象)、配菜(简单对象)、饮料(简单对象)。</p><h3 id="原型模式"><a href="#原型模式" aria-hidden="true" class="header-anchor">#</a> 原型模式</h3><p>通过克隆现有对象来生成新对象，而不是使用类来重新创建一个实例，当新创建一个类实例开销比较大时使用。</p><h2 id="结构型模式-对象与对象的关系"><a href="#结构型模式-对象与对象的关系" aria-hidden="true" class="header-anchor">#</a> 结构型模式 - 对象与对象的关系</h2><h3 id="适配器模式"><a href="#适配器模式" aria-hidden="true" class="header-anchor">#</a> 适配器模式</h3><p>作为两个不兼容接口之间的桥梁。通过继承或依赖其中一个对象，实现另一个接口功能。
比如内存卡不能直接连接到电脑，通过读卡器就可以。</p><p>实现方法：适配器类中使用接口1的实现类，然后接口2的实现类中使用适配器类来使用接口1的实现类的方法。</p><h3 id="桥接模式"><a href="#桥接模式" aria-hidden="true" class="header-anchor">#</a> 桥接模式</h3><p>将抽象化和实现化解耦，使两者可以独立变化。</p><p>比如我们要画多种不同颜色的圆</p><ul><li>正常做法：创建一个shape抽象类，然后创建一个继承shape抽象类的circle类，然后创建继承circle类的各种颜色的circle类。</li><li>桥接模式：添加一个桥接接口，桥接接口中有画圆的抽象方法，然后各种颜色的circle类实现这个桥接接口，再在shape抽象类中使用桥接接口，这样就可以在继承shape抽象类的circle类中使用桥接接口的画圆方法了，在创建circle类实例时传入对应桥接接口的实现类的实例，就可以画出对应颜色的圆。好处在于，我可以再直接创建一些实现了桥接接口的画各种颜色rectangle的类，而不需要先创建一个继承shape抽象类的rectangle类。</li></ul><h3 id="过滤器模式-标准模式"><a href="#过滤器模式-标准模式" aria-hidden="true" class="header-anchor">#</a> 过滤器模式/标准模式 **</h3><p>就是我们常用的过滤器，使用不同的标准(过滤器函数)从一组数据中过滤出符合标准的部分数据，或者将输入数据加工处理转变成想要的输出数据。</p><h3 id="组合模式-树模式-部分整体模式"><a href="#组合模式-树模式-部分整体模式" aria-hidden="true" class="header-anchor">#</a> 组合模式/树模式/部分整体模式</h3><p>将一组存在上下级关系的相似对象组合成一个树形结构，用统一的方式来处理这些对象，就像树一样，上一级节点对象中包含下一级节点对象，我们只需要关注一个节点的处理，然后递归的处理其他所有节点。</p><p>算法题中常见的树结构相关的解题方法应该就是用了这个设计模式。</p><h3 id="装饰器模式"><a href="#装饰器模式" aria-hidden="true" class="header-anchor">#</a> 装饰器模式 *</h3><p>给现有的类提供额外的功能，同时又不改变其结构，其实就是对现有的类的一个包装。
装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><h3 id="外观模式"><a href="#外观模式" aria-hidden="true" class="header-anchor">#</a> 外观模式</h3><p>定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。
比如一个系统提供了10个接口，我们正常使用时需要分别去调用这10个接口，使用外观模式，我们可以在高层再添加一个接口，用这个接口去调用这10个接口，然后使用时只需要调用这个高层接口就好了，可以通过参数去控制具体调用哪个接口。</p><h3 id="享元模式"><a href="#享元模式" aria-hidden="true" class="header-anchor">#</a> 享元模式 *</h3><p>重用现有的同类对象，如果未找到，则创建一个新对象。
主要用于减少创建对象的数量，以减少内存占用和提高性能。</p><p>如果一个类创建了大量的实例对象，而这些实例对象除了少数几个参数外其他都相同，那么就可以将相同的部分单独提取出来，在方法调用时通过参数传递进来，就可以重用这一部分。</p><h3 id="代理模式"><a href="#代理模式" aria-hidden="true" class="header-anchor">#</a> 代理模式 *</h3><p>在现有对象上添加一个代理层，用来控制对这个对象的访问。通常代理就是拦截原有的操作，在代理层中重新自定义操作。</p><h2 id="行为型模式-对象与对象在干嘛"><a href="#行为型模式-对象与对象在干嘛" aria-hidden="true" class="header-anchor">#</a> 行为型模式 - 对象与对象在干嘛</h2><h3 id="责任链模式"><a href="#责任链模式" aria-hidden="true" class="header-anchor">#</a> 责任链模式</h3><p>将请求和接收解耦，不需要明确指定一个请求由哪个接收者处理，而是把所有的接收者串联成一条链，请求只需要发送到这条接收链上，接收链会自动一级一级的确认由哪个接收者处理。前一个接收者不能处理就传递给下一个，接收链上的每一个接收者都存有对下一个接收者的引用。</p><h3 id="命令模式"><a href="#命令模式" aria-hidden="true" class="header-anchor">#</a> 命令模式</h3><p>将请求和接收解耦，请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p>模式分析：</p><ol><li>命令模式的本质是<strong>对命令进行封装，将发出命令的责任和执行命令的责任分割开</strong>。</li><li>每一个命令都是一个操作：<strong>请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作</strong>。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得<strong>请求的一方不必知道接收的一方的接口</strong>，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ol><p>个人理解：</p><p>系统命令行输入中，我们输入的命令就是请求对象，终端的命令处理程序就是接收对象，它接收我们输入的命令寻找对应的处理对象来执行我们的命令，终端程序不需要关心我们输入的命令是什么，可以独立编程，然后我们的命令能和它匹配就好了，这样就能将请求与接收解耦。</p><h3 id="解释器模式"><a href="#解释器模式" aria-hidden="true" class="header-anchor">#</a> 解释器模式</h3><p>给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。通常创造新的编程语言的时候才会用到。</p><h3 id="迭代器模式"><a href="#迭代器模式" aria-hidden="true" class="header-anchor">#</a> 迭代器模式</h3><p>抽象出一个迭代器类，将集合对象的遍历操作分离出来。</p><h3 id="中介者模式"><a href="#中介者模式" aria-hidden="true" class="header-anchor">#</a> 中介者模式</h3><p>提供一个中介者，将多个对象之间交互的网状结构分离为星型结构。
比如，中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。</p><h3 id="备忘录模式-快照模式-标记-token-模式"><a href="#备忘录模式-快照模式-标记-token-模式" aria-hidden="true" class="header-anchor">#</a> 备忘录模式/快照模式/标记(Token)模式</h3><p>在不破坏封装性的前提下，捕获一个对象的某个状态，并在对象外保存这个状态，以便在适当的时候恢复到对象的这个状态。
比如，游戏存档。</p><h3 id="观察者模式"><a href="#观察者模式" aria-hidden="true" class="header-anchor">#</a> 观察者模式 **</h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>这个是最常见的了，事件监听器，数据对象监听等等。</p><h3 id="发布订阅模式"><a href="#发布订阅模式" aria-hidden="true" class="header-anchor">#</a> 发布订阅模式 **</h3><p>这是观察者模式最常用的一种，和普通观察者模式的主要区别在于订阅模式中间有一个调度中心，可以用来统一的从发布者接收发布的事件，然后再向对应的订阅者发布事件。</p><h3 id="状态模式"><a href="#状态模式" aria-hidden="true" class="header-anchor">#</a> 状态模式</h3><p>对象的行为依赖于它的状态(属性)，并且可以根据它的状态改变而改变它的相关行为。</p><p>应该就是在对象的方法中，判断对象的属性，根据不同的属性值执行不同的代码。这样就可以通过改变对象的属性值来改变同一个方法的行为。</p><h3 id="空对象模式"><a href="#空对象模式" aria-hidden="true" class="header-anchor">#</a> 空对象模式</h3><p>在空对象模式(Null Object Pattern)中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p><p>这个模式没太搞懂，好像就是专门搞一个类来处理 null 情况，防止客户端报错的，感觉js里面不会用的这种模式。</p><h3 id="策略模式"><a href="#策略模式" aria-hidden="true" class="header-anchor">#</a> 策略模式</h3><p>有多个相似的策略类，仅仅只是行为不同，客户端自行选择使用哪个策略类。
做一件事情有多种方式，提供这几种方式的实现让用户自己选择使用哪种。
比如有飞机，火车，轮船几种出行方式，我们可以自己选择出行方式。</p><h3 id="模板模式"><a href="#模板模式" aria-hidden="true" class="header-anchor">#</a> 模板模式</h3><p>抽象出一个骨架结构，然后再往这个结构中填充内容。
比如常用的html模板，抽象类和接口</p><h3 id="访问者模式"><a href="#访问者模式" aria-hidden="true" class="header-anchor">#</a> 访问者模式</h3><p>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。
即在被访问类中添加一个方法，该方法接收一个访问者对象作为参数传入，然后在方法内部执行访问者对象的方法时将自身引用(this)作为参数传入。</p><h2 id="j2ee-模式-对象合起来要干嘛"><a href="#j2ee-模式-对象合起来要干嘛" aria-hidden="true" class="header-anchor">#</a> J2EE 模式 - 对象合起来要干嘛</h2><h3 id="mvc-模型-视图-控制器-模式"><a href="#mvc-模型-视图-控制器-模式" aria-hidden="true" class="header-anchor">#</a> MVC(模型-视图-控制器)模式</h3><p>模型代表一个存取数据的对象，它也可以带有逻辑，在数据变化时更新控制器。
视图代表模型包含的数据的可视化。
控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p><h3 id="业务代表模式"><a href="#业务代表模式" aria-hidden="true" class="header-anchor">#</a> 业务代表模式</h3><p>将业务实现和前端展示分割，由一个中间代表来连接客户端和业务端，减少客户端和业务端的通信复杂度。
业务实现向外统一暴露接口，由业务代表来具体查询和掉用业务接口执行相关业务，而客户则只需要想业务代表调用相关简化后的接口即可实现响应业务。</p><p>用于对表示层和业务层解耦。
它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。</p><p>在业务层中我们有以下实体。</p><ul><li>客户端(Client)：表示层代码可以是 JSP、servlet 或 UI java 代码。</li><li>业务代表(Business Delegate)：一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。</li><li>查询服务(LookUp Service)：查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。</li><li>业务服务(Business Service)：业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。</li></ul><h3 id="组合实体模式"><a href="#组合实体模式" aria-hidden="true" class="header-anchor">#</a> 组合实体模式</h3><p>用在 EJB 持久化机制中。
一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。</p><p>以下是组合实体 bean 的参与者。</p><ul><li>组合实体(Composite Entity)：它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。</li><li>粗粒度对象(Coarse-Grained Object)：该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。</li><li>依赖对象(Dependent Object)：依赖对象是一个持续生命周期依赖于粗粒度对象的对象。</li><li>策略(Strategies)：策略表示如何实现组合实体。</li></ul><h3 id="数据访问对象-dao-模式"><a href="#数据访问对象-dao-模式" aria-hidden="true" class="header-anchor">#</a> 数据访问对象(DAO)模式</h3><p>用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。</p><p>以下是数据访问对象模式的参与者。</p><ul><li>数据访问对象接口(Data Access Object Interface)：该接口定义了在一个模型对象上要执行的标准操作。</li><li>数据访问对象实体类(Data Access Object concrete class)：该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。</li><li>模型对象/数值对象(Model Object/Value Object)：该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。</li></ul><h3 id="前端控制器模式"><a href="#前端控制器模式" aria-hidden="true" class="header-anchor">#</a> 前端控制器模式</h3><p>用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。</p><p>以下是这种设计模式的实体。</p><ul><li>前端控制器(Front Controller)：处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li><li>调度器(Dispatcher)：前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li><li>视图(View)：视图是为请求而创建的对象。</li></ul><h3 id="拦截过滤器模式"><a href="#拦截过滤器模式" aria-hidden="true" class="header-anchor">#</a> 拦截过滤器模式</h3><p>用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。</p><p>以下是这种设计模式的实体。</p><ul><li>过滤器(Filter)：过滤器在请求处理程序执行请求之前或之后，执行某些任务。</li><li>过滤器链(Filter Chain)：过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。</li><li>Target：Target 对象是请求处理程序。</li><li>过滤管理器(Filter Manager)：过滤管理器管理过滤器和过滤器链。</li><li>客户端(Client)：Client 是向 Target 对象发送请求的对象。</li></ul><h3 id="服务定位器模式"><a href="#服务定位器模式" aria-hidden="true" class="header-anchor">#</a> 服务定位器模式</h3><p>用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。</p><p>以下是这种设计模式的实体。</p><ul><li>服务(Service)：实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。</li><li>Context/初始的Context：JNDI Context 带有对要查找的服务的引用。</li><li>服务定位器(Service Locator)：服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。</li><li>缓存(Cache)：缓存存储服务的引用，以便复用它们。</li><li>客户端(Client)：Client 是通过 ServiceLocator 调用服务的对象。</li></ul><h3 id="传输对象模式"><a href="#传输对象模式" aria-hidden="true" class="header-anchor">#</a> 传输对象模式</h3><p>用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。</p><p>以下是这种设计模式的实体。</p><ul><li>业务对象(Business Object)：为传输对象填充数据的业务服务。</li><li>传输对象(Transfer Object)：简单的 POJO，只有设置/获取属性的方法。</li><li>客户端(Client)：客户端可以发送请求或者发送传输对象到业务对象。</li></ul></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/jottings/learn-by-self.html" class="prev">
          杂记
        </a></span><span class="next"><a href="/jottings/web-security.html">
          web安全及处理
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/19.55416f59.js" defer></script><script src="/assets/js/app.3681f687.js" defer></script>
  </body>
</html>
