# Http 协议相关记录

### http1.x 和 http/2 的区别

> [浅谈 HTTP/2 Server Push](https://zhuanlan.zhihu.com/p/26757514)

- keep-alive：保持一次TCP连接之后不断开，可以在一个TCP连接中多次请求与响应，减少了昂贵的TCP建立连接和断开连接的过程。
- http流水线(http pipelining)：允许客户端在收到响应之前继续发送幂等方法(GET和HEAD)的请求，正常情况下是要等收到上一个响应后才能发送下一个请求，该技术已经被http/2的多路复用取代。该技术相比http/2的多路复用存在一个问题就是，先请求的访问也要先返回响应，因此可能出现较慢响应阻塞较快响应的情况。

http1.1的TCP长连接可以复用，但是一次只能发送一个请求，下一个请求的发送要等上个请求发送完成之后才能复用这个TCP连接，但是不需要等待服务器返回上一个请求的结果，这个就是http流水线的功能。http1.1的TCP连接还是会开多个的，比如同时请求10个资源，而浏览器最大TCP连接数只有6，那么浏览器就会开6个TCP连接，有4个资源要等待前6个资源请求发送，如果哪个请求发送完了，那么它的TCP连接就会空闲出来，然后就会被复用来发送下一个资源请求。
http1.0的TCP短连接每次请求完之后TCP连接都会关闭，下一个请求又重新进行三次握手连接。

小结：http/1.1虽然keep-alive保持了TCP连接，但多次数据传输还是在一个管道中进行，所以数据传输存在先后顺序，前面的会阻塞后面的，而http/2多个数据传输是在多个独立管道(其实是stream)中进行，流可以是单向的，也可以是双向的，一个请求及其响应就单独开一个流，因而多个数据传输不会互相阻塞。注意：使用server push一个请求也可以返回多个响应，每个响应在不同的流中返回。主动推送的资源会在你请求的资源数据返回之前先返回一个PUSH_PROMISE帧（通过给流设置优先级，http/2可以给每个流设置优先级和依赖，优先级高的流会被服务器优先处理和返回给客户端），告知客户端哪个资源将被推送，无需再次请求。

> [http/2 frame(帧)](https://http2.github.io/http2-spec/index.html#FrameTypes)
> [http/2 stream(流)](https://http2.github.io/http2-spec/index.html#StreamsLayer)

header frame：存放请求/响应头部分的数据
data frame：存放请求/响应数据体部分的数据

http/2的好处：二进制传输，多路复用，首部压缩，优先级控制，server push。
server push本质上其实就是服务器代替客户端做了一次请求，并将请求结果返回给客户端。
server push推送的资源必须是可缓存的，安全的，并且没有请求体的，即可以推送GET和HEAD的响应。

- 安全方法：GET、HEAD、OPTIONS、TRACE
- 幂等方法：PUT、DELETE、安全方法
- 可缓存方法：GET、HEAD、POST，虽然规范中POST方法也是可缓存的，然而实际大多数实现只支持GET和HEAD

> [safe | idempotent | cacheable methods](https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#method.properties)

### SSL/TLS 握手流程

1. 客户端请求建立SSL连接
    1. 生成一个随机数(Client random)
    2. 准备好客户端支持的“对称加密密钥生成算法”和“hash算法”
    3. 向服务端发送以上所有，此时是明文传输
2. 服务端接收到客户端的请求
    1. 生成一个随机数(Server random)
    2. 从客户端支持的加密算法中选择一组算法(包含一个“对称加密密钥生成算法”和一个“hash算法”)
    3. 准备好包含自己身份信息的证书(证书里包含了网站地址，公钥，证书颁发机构等信息)
    4. 向客户端发送以上所有，此时还是明文传输
3. 客户端接收到服务端的响应
    1. 生成一个随机数(Premaster secret)
    2. 验证证书的合法性(颁发机构是否合法，证书中包含的网址是否和正在访问的一样)，并提取出证书中的公钥，并使用公钥加密随机数(Premaster secret)
    3. 此时客户端有3个随机数，使用这3个随机数通过协商好的“对称加密密钥生成算法”生成一个对称加密的密钥(session key)
    4. 生成一个握手消息，使用“hash算法”加密这个握手消息生成一个hash指纹，使用对称加密密钥(session key)对这个握手消息进行加密生成一个握手消息密文
    5. 向服务端发送公钥加密的随机数、hash指纹、握手消息密文，此时是密文传输
4. 服务端接收到客户端的请求
    1. 使用私钥解密公钥加密的随机数，获得随机数(Premaster secret)
    2. 此时服务端也有3个随机数，也使用这3个随机数通过协商好的“对称加密密钥生成算法”生成一个对称加密的密钥(session key)
    3. 使用对称加密密钥(session key)解密握手消息密文，获得握手消息，然后使用“hash算法”加密这个握手消息生成一个hash指纹，将这个hash指纹和客户端传过来的hash指纹进行比较，一致说明生成的对称加密密钥(session key)是正确的
    4. 生成一个新的握手消息，使用“hash算法”加密这个新的握手消息生成一个新的hash指纹，然后使用对称加密密钥(session key)对这个新的握手消息进行加密生成新的握手消息密文
    5. 向客户端发送新的hash指纹、新的握手消息密文
5. 客户端接收到服务端的响应
    1. 使用对称加密密钥(session key)解密握手消息密文，获得握手消息，然后使用“hash算法”加密这个握手消息生成一个hash指纹，将这个hash指纹和服务端传过来的hash指纹进行比较，一致说明客户端生成的对称加密密钥(session key)也是正确的
    2. 握手成功。之后所有的http通信数据都使用这个对称加密密钥(session key)进行加解密。


