(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{53:function(t,e,s){"use strict";s.r(e);var h=s(0),r=Object(h.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"http-协议相关记录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-协议相关记录","aria-hidden":"true"}},[t._v("#")]),t._v(" Http 协议相关记录")]),s("h3",{attrs:{id:"http1-x-和-http-2-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http1-x-和-http-2-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" http1.x 和 http/2 的区别")]),s("blockquote",[s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/26757514",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈 HTTP/2 Server Push")])])]),s("ul",[s("li",[t._v("keep-alive：保持一次TCP连接之后不断开，可以在一个TCP连接中多次请求与响应，减少了昂贵的TCP建立连接和断开连接的过程。")]),s("li",[t._v("http流水线(http pipelining)：允许客户端在收到响应之前继续发送幂等方法(GET和HEAD)的请求，正常情况下是要等收到上一个响应后才能发送下一个请求，该技术已经被http/2的多路复用取代。该技术相比http/2的多路复用存在一个问题就是，先请求的访问也要先返回响应，因此可能出现较慢响应阻塞较快响应的情况。")])]),s("p",[t._v("http1.1的TCP长连接可以复用，但是一次只能发送一个请求，下一个请求的发送要等上个请求发送完成之后才能复用这个TCP连接，但是不需要等待服务器返回上一个请求的结果，这个就是http流水线的功能。http1.1的TCP连接还是会开多个的，比如同时请求10个资源，而浏览器最大TCP连接数只有6，那么浏览器就会开6个TCP连接，有4个资源要等待前6个资源请求发送，如果哪个请求发送完了，那么它的TCP连接就会空闲出来，然后就会被复用来发送下一个资源请求。\nhttp1.0的TCP短连接每次请求完之后TCP连接都会关闭，下一个请求又重新进行三次握手连接。")]),s("p",[t._v("小结：http/1.1虽然keep-alive保持了TCP连接，但多次数据传输还是在一个管道中进行，所以数据传输存在先后顺序，前面的会阻塞后面的，而http/2多个数据传输是在多个独立管道(其实是stream)中进行，流可以是单向的，也可以是双向的，一个请求及其响应就单独开一个流，因而多个数据传输不会互相阻塞。注意：使用server push一个请求也可以返回多个响应，每个响应在不同的流中返回。主动推送的资源会在你请求的资源数据返回之前先返回一个PUSH_PROMISE帧（通过给流设置优先级，http/2可以给每个流设置优先级和依赖，优先级高的流会被服务器优先处理和返回给客户端），告知客户端哪个资源将被推送，无需再次请求。")]),s("blockquote",[s("p",[s("a",{attrs:{href:"https://http2.github.io/http2-spec/index.html#FrameTypes",target:"_blank",rel:"noopener noreferrer"}},[t._v("http/2 frame(帧)")]),s("a",{attrs:{href:"https://http2.github.io/http2-spec/index.html#StreamsLayer",target:"_blank",rel:"noopener noreferrer"}},[t._v("http/2 stream(流)")])])]),s("p",[t._v("header frame：存放请求/响应头部分的数据\ndata frame：存放请求/响应数据体部分的数据")]),s("p",[t._v("http/2的好处：二进制传输，多路复用，首部压缩，优先级控制，server push。\nserver push本质上其实就是服务器代替客户端做了一次请求，并将请求结果返回给客户端。\nserver push推送的资源必须是可缓存的，安全的，并且没有请求体的，即可以推送GET和HEAD的响应。")]),s("ul",[s("li",[t._v("安全方法：GET、HEAD、OPTIONS、TRACE")]),s("li",[t._v("幂等方法：PUT、DELETE、安全方法")]),s("li",[t._v("可缓存方法：GET、HEAD、POST，虽然规范中POST方法也是可缓存的，然而实际大多数实现只支持GET和HEAD")])]),s("blockquote",[s("p",[s("a",{attrs:{href:"https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#method.properties",target:"_blank",rel:"noopener noreferrer"}},[t._v("safe | idempotent | cacheable methods")])])]),s("h3",{attrs:{id:"ssl-tls-握手流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls-握手流程","aria-hidden":"true"}},[t._v("#")]),t._v(" SSL/TLS 握手流程")]),s("ol",[s("li",[t._v("客户端请求建立SSL连接\n"),s("ol",[s("li",[t._v("生成一个随机数(Client random)")]),s("li",[t._v("准备好客户端支持的“对称加密密钥生成算法”和“hash算法”")]),s("li",[t._v("向服务端发送以上所有，此时是明文传输")])])]),s("li",[t._v("服务端接收到客户端的请求\n"),s("ol",[s("li",[t._v("生成一个随机数(Server random)")]),s("li",[t._v("从客户端支持的加密算法中选择一组算法(包含一个“对称加密密钥生成算法”和一个“hash算法”)")]),s("li",[t._v("准备好包含自己身份信息的证书(证书里包含了网站地址，公钥，证书颁发机构等信息)")]),s("li",[t._v("向客户端发送以上所有，此时还是明文传输")])])]),s("li",[t._v("客户端接收到服务端的响应\n"),s("ol",[s("li",[t._v("生成一个随机数(Premaster secret)")]),s("li",[t._v("验证证书的合法性(颁发机构是否合法，证书中包含的网址是否和正在访问的一样)，并提取出证书中的公钥，并使用公钥加密随机数(Premaster secret)")]),s("li",[t._v("此时客户端有3个随机数，使用这3个随机数通过协商好的“对称加密密钥生成算法”生成一个对称加密的密钥(session key)")]),s("li",[t._v("生成一个握手消息，使用“hash算法”加密这个握手消息生成一个hash指纹，使用对称加密密钥(session key)对这个握手消息进行加密生成一个握手消息密文")]),s("li",[t._v("向服务端发送公钥加密的随机数、hash指纹、握手消息密文，此时是密文传输")])])]),s("li",[t._v("服务端接收到客户端的请求\n"),s("ol",[s("li",[t._v("使用私钥解密公钥加密的随机数，获得随机数(Premaster secret)")]),s("li",[t._v("此时服务端也有3个随机数，也使用这3个随机数通过协商好的“对称加密密钥生成算法”生成一个对称加密的密钥(session key)")]),s("li",[t._v("使用对称加密密钥(session key)解密握手消息密文，获得握手消息，然后使用“hash算法”加密这个握手消息生成一个hash指纹，将这个hash指纹和客户端传过来的hash指纹进行比较，一致说明生成的对称加密密钥(session key)是正确的")]),s("li",[t._v("生成一个新的握手消息，使用“hash算法”加密这个新的握手消息生成一个新的hash指纹，然后使用对称加密密钥(session key)对这个新的握手消息进行加密生成新的握手消息密文")]),s("li",[t._v("向客户端发送新的hash指纹、新的握手消息密文")])])]),s("li",[t._v("客户端接收到服务端的响应\n"),s("ol",[s("li",[t._v("使用对称加密密钥(session key)解密握手消息密文，获得握手消息，然后使用“hash算法”加密这个握手消息生成一个hash指纹，将这个hash指纹和服务端传过来的hash指纹进行比较，一致说明客户端生成的对称加密密钥(session key)也是正确的")]),s("li",[t._v("握手成功。之后所有的http通信数据都使用这个对称加密密钥(session key)进行加解密。")])])])])])}],!1,null,null,null);e.default=r.exports}}]);