(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{79:function(e,o,n){"use strict";n.r(o);var i=n(0),l=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,o=e.$createElement,n=e._self._c||o;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"webpack相关记录"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack相关记录","aria-hidden":"true"}},[e._v("#")]),e._v(" Webpack相关记录")]),n("h3",{attrs:{id:"runtime-和-manifest"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runtime-和-manifest","aria-hidden":"true"}},[e._v("#")]),e._v(" runtime 和 manifest")]),n("p",[e._v("webpack打包编译过程中会给每个模块分配一个唯一的模块标识符(module identifier)，我们写代码时使用的模块引入语句import或require会被转换成__webpack_require__方法，而此方法会通过模块标识符来引入模块，manifest中存放的就是模块标识符及其对应模块文件的映射关系数据，runtime是代码运行时用来加载和解析依赖模块的逻辑代码，runtime会根据manifest中的映射关系找到对应的需要加载的模块代码。")]),n("p",[n("a",{attrs:{href:"https://www.webpackjs.com/concepts/manifest/",target:"_blank",rel:"noopener noreferrer"}},[e._v("manifest 和 runtime")]),n("a",{attrs:{href:"https://www.webpackjs.com/concepts/hot-module-replacement/#%E5%9C%A8%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD",target:"_blank",rel:"noopener noreferrer"}},[e._v("HMR manifest")]),n("a",{attrs:{href:"https://www.webpackjs.com/concepts/hot-module-replacement/#%E5%9C%A8-hmr-runtime-%E4%B8%AD",target:"_blank",rel:"noopener noreferrer"}},[e._v("HMR runtime")])]),n("h3",{attrs:{id:"compiler-hooks-执行顺序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compiler-hooks-执行顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" compiler hooks 执行顺序")]),n("ul",[n("li",[e._v("environment: new SyncHook([])")]),n("li",[e._v("afterEnvironment: new SyncHook([])")]),n("li",[e._v('entryOption: new SyncBailHook(["context", "entry"])')]),n("li",[e._v('afterPlugins: new SyncHook(["compiler"])')]),n("li",[e._v('afterResolvers: new SyncHook(["compiler"])')]),n("li",[e._v('beforeRun: new AsyncSeriesHook(["compiler"])')]),n("li",[e._v('run: new AsyncSeriesHook(["compiler"])')]),n("li",[n("ul",[n("li",[e._v('watchRun: new AsyncSeriesHook(["compiler"]) -- 开启watch模式时触发')])])]),n("li",[e._v('normalModuleFactory: new SyncHook(["normalModuleFactory"])')]),n("li",[e._v('contextModuleFactory: new SyncHook(["contextModulefactory"])')]),n("li",[e._v('beforeCompile: new AsyncSeriesHook(["params"]) -- 多次触发?')]),n("li",[e._v('compile: new SyncHook(["params"])')]),n("li",[e._v('thisCompilation: new SyncHook(["compilation", "params"])')]),n("li",[e._v('compilation: new SyncHook(["compilation", "params"]) -- 多次触发?')]),n("li",[e._v('make: new AsyncParallelHook(["compilation"])')]),n("li",[e._v('afterCompile: new AsyncSeriesHook(["compilation"]) -- 多次触发?')]),n("li",[e._v('shouldEmit: new SyncBailHook(["compilation"])\n'),n("ul",[n("li",[e._v('emit: new AsyncSeriesHook(["compilation"])')]),n("li",[e._v('afterEmit: new AsyncSeriesHook(["compilation"])')])])]),n("li",[e._v('done: new AsyncSeriesHook(["stats"])\n'),n("ul",[n("li",[e._v("additionalPass: new AsyncSeriesHook([]) -- 触发受compilation.hooks.needAdditionalPass控制")])])]),n("li",[n("ul",[n("li",[e._v('failed: new SyncHook(["error"]) -- 只要发生错误就会触发')])])]),n("li",[n("ul",[n("li",[e._v('invalid: new SyncHook(["filename", "changeTime"]) -- watch模式下，编译无效时触发')])])]),n("li",[n("ul",[n("li",[e._v("watchClose: new SyncHook([]) -- 关闭watch模式时触发")])])])]),n("p",[n("a",{attrs:{href:"https://webpack.docschina.org/api/compiler-hooks/",target:"_blank",rel:"noopener noreferrer"}},[e._v("compiler 钩子")])]),n("h3",{attrs:{id:"compilation-hooks-执行顺序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compilation-hooks-执行顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" compilation hooks 执行顺序")]),n("p",[n("strong",[e._v("webpack正常执行流程中都会触发的钩子")])]),n("ul",[n("li",[e._v('buildModule: new SyncHook(["module"]) -- compiler.hooks.make触发之后触发，多次触发，应该是每个模块都会触发一次')])]),n("ol",[n("li",[e._v('succeedModule: new SyncHook(["module"]) (二选一)\n'),n("ul",[n("li",[e._v('succeedEntry: new SyncHook(["entry", "name", "module"])')])])]),n("li",[e._v('failedModule: new SyncHook(["module", "error"]) (二选一)\n'),n("ul",[n("li",[e._v('failedEntry: new SyncHook(["entry", "name", "error"]) (终止后续流程)')])])])]),n("ul",[n("li",[e._v('normalModuleLoader: new SyncHook(["loaderContext", "module"]) -- 与buildModule一对一触发，与succeedModule和failedModule貌似没有明确的先后关系')]),n("li",[e._v('finishModules: new AsyncSeriesHook(["modules"])')]),n("li",[e._v("seal: new SyncHook([])")]),n("li",[e._v('optimizeDependenciesBasic: new SyncBailHook(["modules"])')]),n("li",[e._v('optimizeDependencies: new SyncBailHook(["modules"])')]),n("li",[e._v('optimizeDependenciesAdvanced: new SyncBailHook(["modules"])')]),n("li",[e._v('afterOptimizeDependencies: new SyncHook(["modules"])')]),n("li",[e._v("beforeChunks: new SyncHook([]) -- 触发该hook之后就会构建chunks")]),n("li",[e._v('dependencyReference: new SyncWaterfallHook(["dependencyReference", "dependency", "module"]) -- 多次触发?')]),n("li",[e._v('afterChunks: new SyncHook(["chunks"])')]),n("li",[e._v("optimize: new SyncHook([])")]),n("li",[e._v('optimizeModulesBasic: new SyncBailHook(["modules"])')]),n("li",[e._v('optimizeModules: new SyncBailHook(["modules"])')]),n("li",[e._v('optimizeModulesAdvanced: new SyncBailHook(["modules"])')]),n("li",[e._v('afterOptimizeModules: new SyncHook(["modules"])')]),n("li",[e._v('optimizeChunksBasic: new SyncBailHook(["chunks", "chunkGroups"])')]),n("li",[e._v('optimizeChunks: new SyncBailHook(["chunks", "chunkGroups"])')]),n("li",[e._v('optimizeChunksAdvanced: new SyncBailHook(["chunks", "chunkGroups"])')]),n("li",[e._v('afterOptimizeChunks: new SyncHook(["chunks", "chunkGroups"])')]),n("li",[e._v('optimizeTree: new AsyncSeriesHook(["chunks", "modules"])')]),n("li",[e._v('afterOptimizeTree: new SyncHook(["chunks", "modules"])')]),n("li",[e._v('optimizeChunkModulesBasic: new SyncBailHook(["chunks", "modules"])')]),n("li",[e._v('optimizeChunkModules: new SyncBailHook(["chunks", "modules"])')]),n("li",[e._v('optimizeChunkModulesAdvanced: new SyncBailHook(["chunks", "modules"])')]),n("li",[e._v('afterOptimizeChunkModules: new SyncHook(["chunks", "modules"])')]),n("li",[e._v("shouldRecord: new SyncBailHook([])")]),n("li",[e._v('reviveModules: new SyncHook(["modules", "records"])')]),n("li",[e._v('optimizeModuleOrder: new SyncHook(["modules"])')]),n("li",[e._v('advancedOptimizeModuleOrder: new SyncHook(["modules"])')]),n("li",[e._v('beforeModuleIds: new SyncHook(["modules"])')]),n("li",[e._v('moduleIds: new SyncHook(["modules"])')]),n("li",[e._v('optimizeModuleIds: new SyncHook(["modules"])')]),n("li",[e._v('afterOptimizeModuleIds: new SyncHook(["modules"])')]),n("li",[e._v('reviveChunks: new SyncHook(["chunks", "records"])')]),n("li",[e._v('optimizeChunkOrder: new SyncHook(["chunks"])')]),n("li",[e._v('beforeChunkIds: new SyncHook(["chunks"])')]),n("li",[e._v('optimizeChunkIds: new SyncHook(["chunks"])')]),n("li",[e._v('afterOptimizeChunkIds: new SyncHook(["chunks"])\n'),n("ul",[n("li",[e._v('recordModules: new SyncHook(["modules", "records"]) -- 触发受shouldRecord控制')]),n("li",[e._v('recordChunks: new SyncHook(["chunks", "records"]) -- 触发受shouldRecord控制')])])]),n("li",[e._v("beforeHash: new SyncHook([])")]),n("li",[e._v('chunkHash: new SyncHook(["chunk", "chunkHash"])')]),n("li",[e._v('contentHash: new SyncHook(["chunk"])')]),n("li",[e._v("afterHash: new SyncHook([])\n"),n("ul",[n("li",[e._v('recordHash: new SyncHook(["records"]) -- 触发受shouldRecord控制')])])]),n("li",[e._v("beforeModuleAssets: new SyncHook([])")]),n("li",[e._v('mainTemplate.hooks.assetPath: new SyncWaterfallHook(["path", "options"])')]),n("li",[e._v('moduleAsset: new SyncHook(["module", "filename"])')]),n("li",[e._v("shouldGenerateChunkAssets: new SyncBailHook([])\n"),n("ul",[n("li",[e._v("beforeChunkAssets: new SyncHook([])")]),n("li",[e._v('mainTemplate.hooks.assetPath: new SyncWaterfallHook(["path", "options"])')]),n("li",[e._v('chunkAsset: new SyncHook(["chunk", "filename"])')])])]),n("li",[e._v('additionalChunkAssets: new SyncHook(["chunks"])\n'),n("ul",[n("li",[e._v('record: new SyncHook(["compilation", "records"]) -- 触发受shouldRecord控制')])])]),n("li",[e._v("additionalAssets: new AsyncSeriesHook([])")]),n("li",[e._v('optimizeChunkAssets: new AsyncSeriesHook(["chunks"])')]),n("li",[e._v('afterOptimizeChunkAssets: new SyncHook(["chunks"])')]),n("li",[e._v('optimizeAssets: new AsyncSeriesHook(["assets"])')]),n("li",[e._v('afterOptimizeAssets: new SyncHook(["assets"])')]),n("li",[e._v("needAdditionalSeal: new SyncBailHook([])\n"),n("ul",[n("li",[e._v("unseal: new SyncHook([])")]),n("li",[e._v("seal: new SyncHook([]) (循环)")])])]),n("li",[e._v("afterSeal: new AsyncSeriesHook([]) -- compiler.hooks.afterCompile触发之前触发")]),n("li",[e._v("needAdditionalPass: new SyncBailHook([])")])]),n("p",[n("em",[e._v("compilation.hooks基本都是compiler.hooks.make和compiler.hooks.afterCompile之间触发的")])]),n("p",[n("strong",[e._v("需要在插件中调用compilation.prototype中的方法才会触发的钩子")])]),n("ul",[n("li",[e._v('addEntry: new SyncHook(["entry", "name"]) -- 这个hook存在于webpack-stream包的compilation中，在webpack包的compilation中不存在，所以通常不能用，还有succeedEntry和failedEntry也是。但是，两者的compilation原型对象上都有addEntry(context, entry, name, callback)方法，触发时机取决于compilation.addEntry方法的调用时间。')]),n("li",[e._v('childCompiler: new SyncHook(["childCompiler", "compilerName", "compilerIndex"]) -- 插件中调用compilation.createChildCompiler方法时触发')]),n("li",[e._v('rebuildModule: new SyncHook(["module"]) -- 插件中调用compilation.rebuildModule方法时才会触发\n'),n("ul",[n("li",[e._v('buildModule: new SyncHook(["module"])')])]),n("ol",[n("li",[e._v('succeedModule: new SyncHook(["module"]) (二选一)')]),n("li",[e._v('failedModule: new SyncHook(["module", "error"]) (二选一)')])]),n("ul",[n("li",[e._v('finishRebuildingModule: new SyncHook(["module"]) -- 插件中调用compilation.rebuildModule方法时才会触发')])])])]),n("p",[n("strong",[e._v("貌似暂时没设置触发时机的钩子，可能会在webpack5中删除")])]),n("ul",[n("li",[e._v('optimizeExtractedChunksBasic: new SyncBailHook(["chunks"])')]),n("li",[e._v('optimizeExtractedChunks: new SyncBailHook(["chunks"])')]),n("li",[e._v('optimizeExtractedChunksAdvanced: new SyncBailHook(["chunks"])')]),n("li",[e._v('afterOptimizeExtractedChunks: new SyncHook(["chunks"])')])]),n("p",[n("strong",[e._v("暂时未使用到的钩子")])]),n("ul",[n("li",[e._v('assetPath: new SyncWaterfallHook(["filename", "data"]) -- 貌似等同于mainTemplate.hooks.assetPath: new SyncWaterfallHook(["path", "options"])')])]),n("h3",{attrs:{id:"tapable"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tapable","aria-hidden":"true"}},[e._v("#")]),e._v(" tapable")]),n("p",[e._v("Interception不同类型方法的触发时机")]),n("ul",[n("li",[e._v("call: hooks.xxx.(call/callAsync/promise)方法执行时触发")]),n("li",[e._v("tap: hooks.xxx.(call/callAsync/promise)方法执行时触发")]),n("li",[e._v("register: hooks.xxx.(tap/tapAsync/tapPromise)方法执行时触发")])]),n("p",[n("a",{attrs:{href:"https://github.com/webpack/tapable",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tapable")])]),n("h3",{attrs:{id:"webpack各种属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack各种属性","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack各种属性")]),n("p",[e._v("chunk: 包含每个entry和动态import的模块，如果有相同的import模块，只会算一个chunk\nchunk.ids: 如果当前chunk需要依赖其他chunk，ids数组的前面会包含其他chunk的id，否则只有自身id\nmodule: 每次编译，每个模块都会对应一个唯一的模块对象，一个模块的多次引入会复用同一个模块对象。")])])}],!1,null,null,null);o.default=l.exports}}]);