(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{73:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"react-hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks","aria-hidden":"true"}},[t._v("#")]),t._v(" React Hooks")]),a("p",[a("strong",[t._v("useState")])]),a("p",[t._v("其实就是一个特殊的"),a("code",[t._v("useReducer")]),t._v("，底层就是通过"),a("code",[t._v("useReducer")]),t._v("实现。")]),a("p",[a("strong",[t._v("useEffect")])]),a("p",[t._v("相当于原来class写法中的"),a("code",[t._v("componentDidMount")]),t._v("和"),a("code",[t._v("componentDidUpdate")]),t._v("，但是callback是异步执行的，会等到浏览器渲染dom完成才通过MessageChannel/setTimeout触发callback执行。")]),a("p",[a("strong",[t._v("useLayoutEffect")])]),a("p",[t._v("是"),a("code",[t._v("useEffect")]),t._v("的同步版本，相当于原来class写法中的"),a("code",[t._v("componentDidMount")]),t._v("和"),a("code",[t._v("componentDidUpdate")]),t._v("。是在commit阶段执行完之后就会触发callback，不会等待浏览器渲染真实dom完成。")]),a("p",[a("strong",[t._v("useContext")])]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("useContext")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyContext"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),a("p",[t._v("这个hook函数是用来替代如下用法的")]),a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{attrs:{class:"token tag"}},[a("span",{attrs:{class:"token tag"}},[a("span",{attrs:{class:"token punctuation"}},[t._v("<")]),t._v("MyContext.Consumer")]),a("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{attrs:{class:"token plain-text"}},[t._v("\n  ")]),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("value "),a("span",{attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{attrs:{class:"token comment"}},[t._v("/* 基于 context 值进行渲染*/")]),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token plain-text"}},[t._v("\n")]),a("span",{attrs:{class:"token tag"}},[a("span",{attrs:{class:"token tag"}},[a("span",{attrs:{class:"token punctuation"}},[t._v("</")]),t._v("MyContext.Consumer")]),a("span",{attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),a("p",[t._v("没错，只是替代consumer部分，provider部分的写法还是和原来一样")]),a("p",[a("strong",[t._v("useReducer")])]),a("p",[t._v("相当于redux的一个简单实现，用法概念都参考redux。")]),a("p",[a("strong",[t._v("useMemo")])]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" memoizedValue "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("useMemo")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("computeExpensiveValue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("a"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),a("p",[t._v("当依赖改变时，传入的回调函数("),a("code",[t._v("() => computeExpensiveValue(a, b)")]),t._v(")在useMemo调用的时候立即执行，回调函数的返回值即为useMemo调用的返回值，当依赖没变时，传入的回调函数不会执行，useMemo调用的返回值为上一次记忆的结果。")]),a("p",[a("strong",[t._v("useCallback")])]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" memoizedCallback "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("useCallback")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("doSomething")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("a"),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),a("p",[t._v("该hook方法用来缓存匿名函数，当依赖改变时，useCallback调用时会返回一个新的匿名函数，当依赖没变时，useCallback调用时会返回上一次记忆的匿名函数引用。")]),a("p",[a("strong",[t._v("useRef")])]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" refContainer "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("useRef")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("initialValue"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),a("p",[t._v("类似直接使用"),a("code",[t._v("React.createRef()")]),t._v("，但在函数组件中还是应该使用useRef，因为useRef不会在重新渲染时创建新的ref对象，而"),a("code",[t._v("React.createRef()")]),t._v("会重新创建新的。")])])}],!1,null,null,null);s.default=e.exports}}]);